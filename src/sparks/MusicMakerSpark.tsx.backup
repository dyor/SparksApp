import React, { useState, useEffect, useRef } from 'react';
import {
    View,
    Text,
    StyleSheet,
    TouchableOpacity,
    ScrollView,
    Alert,
    ActivityIndicator,
    Switch,
    FlatList,
    Platform,
    Share,
    Modal,
} from 'react-native';
import { Audio, AVPlaybackStatus } from 'expo-av';
import { Ionicons } from '@expo/vector-icons';
import { useTheme } from '../contexts/ThemeContext';
import { useSparkStore } from '../store/sparkStore';
import { HapticFeedback } from '../utils/haptics';
import { MusicMakerService, MusicAnalysisResult } from '../services/MusicMakerService';
import { getChordFrequencies, RHYTHM_PATTERNS, DRUM_PATTERNS } from '../utils/MusicTheory';
import {
    SettingsContainer,
    SettingsScrollView,
    SettingsHeader,
    SettingsFeedbackSection
} from '../components/SettingsComponents';

const GUITAR_STRINGS = [
    { note: 'E', freq: 82.41, id: 'E2' },
    { note: 'A', freq: 110.00, id: 'A2' },
    { note: 'D', freq: 146.83, id: 'D3' },
    { note: 'G', freq: 196.00, id: 'G3' },
    { note: 'B', freq: 246.94, id: 'B3' },
    { note: 'e', freq: 329.63, id: 'E4' },
];

const VolumeControl: React.FC<{
    label: string;
    value: number;
    onChange: (val: number) => void;
    color: string;
}> = ({ label, value, onChange, color }) => (
    <View style={styles.volumeControl}>
        <Text style={[styles.volumeLabel, { color }]}>{label}</Text>
        <View style={styles.volumeBar}>
            {[0.2, 0.4, 0.6, 0.8, 1.0].map((level) => (
                <TouchableOpacity
                    key={level}
                    onPress={() => onChange(level)}
                    style={[
                        styles.volumeSegment,
                        {
                            backgroundColor: value >= level ? color : '#E0E0E0',
                            height: 10 + (level * 10)
                        }
                    ]}
                />
            ))}
        </View>
    </View>
);

const MusicMakerSpark: React.FC<{
    showSettings?: boolean;
    onCloseSettings?: () => void;
}> = ({ showSettings = false, onCloseSettings }) => {
    const { colors } = useTheme();
    const { getSparkData, setSparkData } = useSparkStore();
    const [activeTab, setActiveTab] = useState<'tuner' | 'songs'>('tuner');

    // Tuner State
    const [isTuning, setIsTuning] = useState(false);
    const [currentPitch, setCurrentPitch] = useState<number | null>(null);
    const [closestString, setClosestString] = useState<typeof GUITAR_STRINGS[0] | null>(null);
    const recordingRef = useRef<Audio.Recording | null>(null);
    const audioContextRef = useRef<AudioContext | null>(null);
    const analyserRef = useRef<AnalyserNode | null>(null);
    const microphoneRef = useRef<MediaStreamAudioSourceNode | null>(null);
    const mediaStreamRef = useRef<MediaStream | null>(null);
    const isTuningRef = useRef(false);

    // Web Recording Refs
    const mediaRecorderRef = useRef<MediaRecorder | null>(null);
    const audioChunksRef = useRef<Blob[]>([]);

    // Songs State
    const [songs, setSongs] = useState<MusicAnalysisResult[]>([]);
    const [isRecording, setIsRecording] = useState(false);
    const [isAnalyzing, setIsAnalyzing] = useState(false);
    const [selectedSong, setSelectedSong] = useState<MusicAnalysisResult | null>(null);

    // Notation Toggles
    const [showFlats, setShowFlats] = useState(false);
    const [showSharps, setShowSharps] = useState(true);
    const [showWhole, setShowWhole] = useState(true);

    // Playback Options
    const [playWithChords, setPlayWithChords] = useState(Platform.OS === 'web');
    const [selectedRhythm, setSelectedRhythm] = useState('Downstrum');
    const [playWithDrums, setPlayWithDrums] = useState(false);
    const [playIntro, setPlayIntro] = useState(false);

    // Volume Levels (0.0 - 1.0)
    const [voiceVolume, setVoiceVolume] = useState(1.0);
    const [chordVolume, setChordVolume] = useState(0.6);
    const [drumVolume, setDrumVolume] = useState(0.6);

    // Playback Context for Chords (Web)
    const playbackContextRef = useRef<AudioContext | null>(null);

    useEffect(() => {
        const data = getSparkData('music-maker');
        if (data?.songs) setSongs(data.songs);
    }, []);

    useEffect(() => {
        setSparkData('music-maker', { songs });
    }, [songs]);

    // --- Tuner Logic ---
    const startTuning = async () => {
        try {
            const { status } = await Audio.requestPermissionsAsync();
            if (status !== 'granted') return;

            setIsTuning(true);
            isTuningRef.current = true;
            HapticFeedback.light();

            if (typeof window !== 'undefined' && (window.AudioContext || (window as any).webkitAudioContext)) {
                // Web implementation using Web Audio API
                try {
                    const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
                    audioContextRef.current = new AudioContextClass();
                    analyserRef.current = audioContextRef.current.createAnalyser();
                    analyserRef.current.fftSize = 2048;

                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    mediaStreamRef.current = stream;
                    microphoneRef.current = audioContextRef.current.createMediaStreamSource(stream);
                    microphoneRef.current.connect(analyserRef.current);

                    const bufferLength = analyserRef.current.fftSize;
                    const dataArray = new Float32Array(bufferLength);

                    const updatePitch = () => {
                        if (!isTuningRef.current || !analyserRef.current) return;

                        analyserRef.current.getFloatTimeDomainData(dataArray);
                        const pitch = autoCorrelate(dataArray, audioContextRef.current!.sampleRate);

                        if (pitch !== -1) {
                            setCurrentPitch(pitch);
                            const closest = GUITAR_STRINGS.reduce((prev, curr) =>
                                Math.abs(curr.freq - pitch) < Math.abs(prev.freq - pitch) ? curr : prev
                            );
                            setClosestString(closest);
                        }
                        requestAnimationFrame(updatePitch);
                    };

                    updatePitch();
                } catch (err) {
                    console.error('Web Audio Tuner Error:', err);
                    // Fallback to simulation if web audio fails
                    startSimulatedTuner();
                }
            } else {
                // Native or fallback simulation
                startSimulatedTuner();
            }
        } catch (error) {
            console.error(error);
        }
    };

    const startSimulatedTuner = () => {
        const interval = setInterval(() => {
            if (!isTuningRef.current) {
                clearInterval(interval);
                return;
            }
            const pitch = 110 + (Math.random() * 4 - 2);
            setCurrentPitch(pitch);
            const closest = GUITAR_STRINGS.reduce((prev, curr) =>
                Math.abs(curr.freq - pitch) < Math.abs(prev.freq - pitch) ? curr : prev
            );
            setClosestString(closest);
        }, 500);
    };

    const autoCorrelate = (buffer: Float32Array, sampleRate: number) => {
        // Simple autocorrelation algorithm for pitch detection
        let SIZE = buffer.length;
        let rms = 0;

        for (let i = 0; i < SIZE; i++) {
            rms += buffer[i] * buffer[i];
        }
        rms = Math.sqrt(rms / SIZE);
        if (rms < 0.01) return -1; // Too quiet

        let r1 = 0, r2 = SIZE - 1, thres = 0.2;
        for (let i = 0; i < SIZE / 2; i++) {
            if (Math.abs(buffer[i]) < thres) { r1 = i; break; }
        }
        for (let i = 1; i < SIZE / 2; i++) {
            if (Math.abs(buffer[SIZE - i]) < thres) { r2 = SIZE - i; break; }
        }

        let buf = buffer.slice(r1, r2);
        SIZE = buf.length;

        let c = new Float32Array(SIZE);
        for (let i = 0; i < SIZE; i++) {
            for (let j = 0; j < SIZE - i; j++) {
                c[i] = c[i] + buf[j] * buf[j + i];
            }
        }

        let d = 0; while (c[d] > c[d + 1]) d++;
        let maxval = -1, maxpos = -1;
        for (let i = d; i < SIZE; i++) {
            if (c[i] > maxval) {
                maxval = c[i];
                maxpos = i;
            }
        }
        let T0 = maxpos;

        // Interpolation
        let x1 = c[T0 - 1], x2 = c[T0], x3 = c[T0 + 1];
        let a = (x1 + x3 - 2 * x2) / 2;
        let b = (x3 - x1) / 2;
        if (a) T0 = T0 - b / (2 * a);

        return sampleRate / T0;
    };

    const stopTuning = async () => {
        setIsTuning(false);
        isTuningRef.current = false;
        setCurrentPitch(null);
        setClosestString(null);
        HapticFeedback.medium();

        if (audioContextRef.current) {
            await audioContextRef.current.close();
            audioContextRef.current = null;
        }
        if (microphoneRef.current) {
            microphoneRef.current.disconnect();
            microphoneRef.current = null;
        }
        if (mediaStreamRef.current) {
            mediaStreamRef.current.getTracks().forEach(track => track.stop());
            mediaStreamRef.current = null;
        }
    };

    const startRecordingSong = async () => {
        try {
            // 1. Force stop tuner if it's running
            if (isTuningRef.current) {
                await stopTuning();
                // Wait a bit for the interval and any audio cleanup to settle
                await new Promise(resolve => setTimeout(resolve, 300));
            }

            // 2. Cleanup previous recording object if any
            if (recordingRef.current) {
                console.log('Cleaning up existing recording object...');
                try {
                    const status = await recordingRef.current.getStatusAsync();
                    if (status.canRecord || status.isRecording) {
                        await recordingRef.current.stopAndUnloadAsync();
                    }
                } catch (e) {
                    console.warn('Silent cleanup error:', e);
                }
                recordingRef.current = null;
            }

            const { status } = await Audio.requestPermissionsAsync();
            if (status !== 'granted') {
                Alert.alert('Permission Required', 'Microphone access is needed for recording.');
                return;
            }

            // --- IMMEDIATE UI FEEDBACK ---
            // Set recording state BEFORE the async prepare/record calls
            // to ensure the button color changes instantly.
            setIsRecording(true);
            HapticFeedback.success();



            if (Platform.OS === 'web') {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    // Prefer mp4/aac, fallback to webm
                    const mimeType = MediaRecorder.isTypeSupported('audio/mp4') ? 'audio/mp4' : 'audio/webm';
                    const recorder = new MediaRecorder(stream, { mimeType });
                    mediaRecorderRef.current = recorder;
                    audioChunksRef.current = [];

                    recorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            audioChunksRef.current.push(event.data);
                        }
                    };

                    recorder.start();
                    console.log('Web recording started with mimeType:', mimeType);
                } catch (err) {
                    console.error('Web Recording Error:', err);
                    setIsRecording(false);
                    Alert.alert('Recording Error', 'Could not start web recording.');
                    return;
                }
            } else {
                await Audio.setAudioModeAsync({
                    allowsRecordingIOS: true,
                    playsInSilentModeIOS: true,
                    staysActiveInBackground: false,
                    shouldDuckAndroid: true,
                });
                const recording = new Audio.Recording();
                await recording.prepareToRecordAsync(Audio.RecordingOptionsPresets.HIGH_QUALITY);
                await recording.recordAsync();
                recordingRef.current = recording;
            }

            console.log('Recording started successfully');
        } catch (error: any) {
            console.error('Start Recording Error:', error);
            setIsRecording(false); // Reset if failed
            Alert.alert('Recording Error', `Could not start: ${error.message || 'Check permissions'}`);
            recordingRef.current = null;
        }
    };

    const stopAndAnalyze = async () => {
        if (!recordingRef.current && !mediaRecorderRef.current) return;

        setIsRecording(false);
        setIsAnalyzing(true);
        HapticFeedback.medium();

        try {

            if (Platform.OS === 'web') {
                if (!mediaRecorderRef.current) return;

                await new Promise<void>(resolve => {
                    if (!mediaRecorderRef.current) return resolve();
                    mediaRecorderRef.current.onstop = () => resolve();
                    mediaRecorderRef.current.stop();
                });

                // Stop tracks
                mediaRecorderRef.current.stream.getTracks().forEach(t => t.stop());

                const mimeType = mediaRecorderRef.current.mimeType || 'audio/webm';
                const blob = new Blob(audioChunksRef.current, { type: mimeType });
                const uri = URL.createObjectURL(blob);

                mediaRecorderRef.current = null;

                const result = await MusicMakerService.analyzeVocalRecording(uri, `Song ${songs.length + 1}`, mimeType);
                setSongs([...songs, result]);
                setSelectedSong(result);

            } else {
                await recordingRef.current.stopAndUnloadAsync();
                const uri = recordingRef.current.getURI();
                recordingRef.current = null; // Clear ref after unloading

                if (uri) {
                    const result = await MusicMakerService.analyzeVocalRecording(uri, `Song ${songs.length + 1}`);
                    setSongs([...songs, result]);
                    setSelectedSong(result);
                }
            }
        } catch (error) {
            console.error('Stop and Analyze Error:', error);
            Alert.alert('Analysis Failed', 'Could not process the recording.');
            recordingRef.current = null; // Ensure cleanup on error
            mediaRecorderRef.current = null;
        } finally {
            setIsAnalyzing(false);
        }
    };

    const [playbackPosition, setPlaybackPosition] = useState(0);
    const [isPlaying, setIsPlaying] = useState(false);
    const soundRef = useRef<Audio.Sound | null>(null);

    const exportSong = async () => {
        if (!selectedSong) return;

        try {
            const lines = selectedSong.lyrics.map(l =>
                `[${l.chords}] ${l.text}`
            ).join('\n');

            const content = `
${selectedSong.songName}
Key: ${selectedSong.key} | BPM: ${selectedSong.bpm}

${lines}

Generated by Sparks App
            `.trim();

            await Share.share({
                message: content,
                title: selectedSong.songName
            });
        } catch (error) {
            Alert.alert('Export Error', 'Could not share song.');
        }
    };

    const createDrumSound = (ctx: AudioContext, type: 'kick' | 'snare' | 'hihat', time: number) => {
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();

        if (type === 'kick') {
            osc.frequency.setValueAtTime(150, time);
            osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
            gain.gain.setValueAtTime(1, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
        } else if (type === 'snare') {
            osc.type = 'triangle';
            osc.frequency.setValueAtTime(100, time);
            gain.gain.setValueAtTime(0.5, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
            // Noise burst would be better but keeping simple for now
        } else {
            // Hi-hat
            osc.type = 'square';
            osc.frequency.setValueAtTime(800, time);
            gain.gain.setValueAtTime(0.3, time);
            gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
        }

        osc.connect(gain);
        gain.connect(ctx.destination);

        osc.start(time);
        osc.stop(time + 0.5);
    };

    const formatNote = (note: string) => {
        if (!showWhole && !note.includes('#') && !note.includes('b')) return '';
        if (!showSharps && note.includes('#')) return '';
        if (!showFlats && note.includes('b')) return '';
        return note;
    };


    const playSong = async () => {
        if (!selectedSong) return;

        if (isPlaying) {
            await soundRef.current?.stopAsync();
            setIsPlaying(false);
            setPlaybackPosition(0);

            // Stop web audio chords
            if (playbackContextRef.current) {
                playbackContextRef.current.close();
                playbackContextRef.current = null;
            }
            return;
        }

        try {
            let introDelay = 0;

            // Setup Web Audio for Chords/Drums
            if ((playWithChords || playWithDrums) && Platform.OS === 'web') {
                const AudioContextClass = window.AudioContext || (window as any).webkitAudioContext;
                playbackContextRef.current = new AudioContextClass();
                const ctx = playbackContextRef.current;

                // --- INTRO ---
                if (playIntro && playWithChords) {
                    // Find 3 most common chords
                    const chordCounts: Record<string, number> = {};
                    selectedSong.lyrics.forEach(line => {
                        const chords = line.chords.split(' ');
                        chords.forEach(c => {
                            if (c) chordCounts[c] = (chordCounts[c] || 0) + 1;
                        });
                    });
                    const topChords = Object.entries(chordCounts)
                        .sort((a, b) => b[1] - a[1])
                        .slice(0, 3)
                        .map(([chord]) => chord);

                    const beatDuration = selectedSong.bpm ? (60 / selectedSong.bpm) : 0.5;
                    introDelay = beatDuration * 2 * topChords.length; // 2 beats per chord

                    topChords.forEach((chord, idx) => {
                        const freqs = getChordFrequencies(chord);
                        const rhythm = RHYTHM_PATTERNS[selectedRhythm] || RHYTHM_PATTERNS['Downstrum'];

                        freqs.forEach((freq, i) => {
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();

                            osc.type = 'triangle';
                            osc.frequency.value = freq;

                            const startTime = ctx.currentTime + (idx * beatDuration * 2) + (rhythm.strums[i % rhythm.strums.length] || 0);
                            const duration = beatDuration * 2;

                            gain.gain.setValueAtTime(0, ctx.currentTime);
                            gain.gain.linearRampToValueAtTime(0.1 * chordVolume, startTime + 0.02);
                            gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                            osc.connect(gain);
                            gain.connect(ctx.destination);

                            osc.start(startTime);
                            osc.stop(startTime + duration);
                        });
                    });
                }

                // --- DRUMS ---
                if (playWithDrums && selectedSong.bpm) {
                    const beatDuration = 60 / selectedSong.bpm;
                    const totalDuration = selectedSong.lyrics[selectedSong.lyrics.length - 1].startTime + 5 + introDelay;
                    const pattern = DRUM_PATTERNS['Basic Rock'];

                    for (let t = introDelay; t < totalDuration; t += (beatDuration * 4)) {
                        pattern.forEach(note => {
                            const time = ctx.currentTime + t + note.time * beatDuration;
                            const osc = ctx.createOscillator();
                            const gain = ctx.createGain();

                            if (note.type === 'kick') {
                                osc.frequency.setValueAtTime(150, time);
                                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                                gain.gain.setValueAtTime(1 * drumVolume, time);
                                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
                            } else if (note.type === 'snare') {
                                osc.type = 'triangle';
                                osc.frequency.setValueAtTime(100, time);
                                gain.gain.setValueAtTime(0.5 * drumVolume, time);
                                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                            }

                            osc.connect(gain);
                            gain.connect(ctx.destination);

                            osc.start(time);
                            osc.stop(time + 0.5);
                        });
                    }
                }

                // --- CHORDS ---
                if (playWithChords) {
                    const rhythm = RHYTHM_PATTERNS[selectedRhythm] || RHYTHM_PATTERNS['Downstrum'];
                    selectedSong.lyrics.forEach(line => {
                        const chords = line.chords.split(' ');
                        const firstChord = chords[0];
                        if (firstChord) {
                            const freqs = getChordFrequencies(firstChord);

                            freqs.forEach((freq, i) => {
                                const osc = ctx.createOscillator();
                                const gain = ctx.createGain();

                                osc.type = 'triangle';
                                osc.frequency.value = freq;

                                gain.gain.setValueAtTime(0, ctx.currentTime);
                                const startTime = ctx.currentTime + introDelay + line.startTime + (rhythm.strums[i % rhythm.strums.length] || 0);
                                const duration = 1.5;

                                gain.gain.linearRampToValueAtTime(0.1 * chordVolume, startTime + 0.02);
                                gain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

                                osc.connect(gain);
                                gain.connect(ctx.destination);

                                osc.start(startTime);
                                osc.stop(startTime + duration);
                            });
                        }
                    });
                }
            }

            const { sound } = await Audio.Sound.createAsync({ uri: selectedSong.vocalUri });
            soundRef.current = sound;
            await sound.setVolumeAsync(voiceVolume);
            setIsPlaying(true);
            HapticFeedback.light();

            sound.setOnPlaybackStatusUpdate((status: AVPlaybackStatus) => {
                if (status.isLoaded) {
                    setPlaybackPosition(status.positionMillis / 1000);
                    if (status.didJustFinish) {
                        setIsPlaying(false);
                        setPlaybackPosition(0);
                        if (playbackContextRef.current) {
                            playbackContextRef.current.close();
                            playbackContextRef.current = null;
                        }
                    }
                }
            });

            // Delay vocal start if intro is playing
            if (introDelay > 0) {
                setTimeout(async () => {
                    await sound.playAsync();
                }, introDelay * 1000);
            } else {
                await sound.playAsync();
            }
        } catch (error) {
            console.error('Playback Error:', error);
            Alert.alert('Playback Error', 'Could not play the recording.');
        }
    };

    useEffect(() => {
        return () => {
            soundRef.current?.unloadAsync();
        };
    }, []);

    if (showSettings) {
        return (
            <SettingsContainer>
                <SettingsScrollView>
                    <SettingsHeader title="Music Maker" subtitle="Guitar tools" icon="üé∏" sparkId="music-maker" />

                    <View style={[styles.helpSection, { backgroundColor: colors.surface, borderColor: colors.border }]}>
                        <Text style={[styles.helpTitle, { color: colors.primary }]}>How it Works</Text>

                        <View style={styles.helpItem}>
                            <Text style={[styles.helpSubitle, { color: colors.text }]}>üé∏ Tuning Your Guitar</Text>
                            <Text style={[styles.helpText, { color: colors.textSecondary }]}>
                                Start the tuner and pluck a string. The meter shows if you're sharp or flat.
                                Aim for the center green needle!
                            </Text>
                        </View>

                        <View style={styles.helpItem}>
                            <Text style={[styles.helpSubitle, { color: colors.text }]}>üéôÔ∏è Recording a Song</Text>
                            <Text style={[styles.helpText, { color: colors.textSecondary }]}>
                                Go to the "Songs" tab and tap the microphone. Sing your song clearly.
                                When finished, tap stop to let Gemini analyze the melody and chords.
                            </Text>
                        </View>
                    </View>

                    <SettingsFeedbackSection sparkId="music-maker" sparkName="Music Maker" />
                    <TouchableOpacity onPress={onCloseSettings} style={styles.closeBtn}>
                        <Text style={{ color: colors.text }}>Close</Text>
                    </TouchableOpacity>
                </SettingsScrollView>
            </SettingsContainer>
        );
    }

    return (
        <View style={[styles.container, { backgroundColor: colors.background }]}>
            <View style={styles.tabs}>
                <TouchableOpacity
                    onPress={() => setActiveTab('tuner')}
                    style={[styles.tab, activeTab === 'tuner' && { borderBottomColor: colors.primary, borderBottomWidth: 2 }]}
                >
                    <Text style={[styles.tabText, { color: activeTab === 'tuner' ? colors.primary : colors.textSecondary }]}>Tuner</Text>
                </TouchableOpacity>
                <TouchableOpacity
                    onPress={() => setActiveTab('songs')}
                    style={[styles.tab, activeTab === 'songs' && { borderBottomColor: colors.primary, borderBottomWidth: 2 }]}
                >
                    <Text style={[styles.tabText, { color: activeTab === 'songs' ? colors.primary : colors.textSecondary }]}>Songs</Text>
                </TouchableOpacity>
            </View>

            {activeTab === 'tuner' ? (
                <View style={styles.tunerContainer}>
                    <View style={styles.meter}>
                        <Text style={[styles.pitchText, { color: colors.text }]}>
                            {currentPitch ? `${currentPitch.toFixed(2)} Hz` : '---'}
                        </Text>
                        <Text style={[styles.noteText, { color: colors.primary }]}>
                            {closestString?.note || '?'}
                        </Text>

                        <View style={styles.visualMeter}>
                            <View style={[styles.meterLine, { backgroundColor: colors.textSecondary + '40' }]} />
                            <View style={[styles.meterCenter, { backgroundColor: colors.primary }]} />
                            {currentPitch && closestString ? (() => {
                                const cents = 1200 * Math.log2(currentPitch / closestString.freq);
                                const clampedCents = Math.max(-50, Math.min(50, cents));
                                const leftPosition = 50 + clampedCents; // 0-100%
                                return (
                                    <>
                                        <View style={[styles.needle, { left: `${leftPosition}%`, backgroundColor: Math.abs(cents) < 5 ? '#4CAF50' : colors.error }]} />
                                        <Text style={[styles.centsText, { color: Math.abs(cents) < 5 ? '#4CAF50' : colors.textSecondary }]}>
                                            {cents > 0 ? '+' : ''}{cents.toFixed(0)} cents
                                        </Text>
                                    </>
                                );
                            })() : (
                                <Text style={[styles.centsText, { color: colors.textSecondary, opacity: 0.5 }]}>Ready</Text>
                            )}
                        </View>
                    </View>
                    <View style={styles.stringGrid}>
                        {GUITAR_STRINGS.map(s => (
                            <View key={s.id} style={[styles.stringTag, closestString?.id === s.id && { backgroundColor: colors.primary }]}>
                                <Text style={{ color: closestString?.id === s.id ? '#fff' : colors.textSecondary }}>{s.note}</Text>
                            </View>
                        ))}
                    </View>
                    <TouchableOpacity
                        onPress={isTuning ? () => stopTuning() : startTuning}
                        style={[styles.actionBtn, { backgroundColor: isTuning ? colors.error : colors.primary }]}
                    >
                        <Text style={{ color: '#fff', fontWeight: 'bold' }}>{isTuning ? 'Stop' : 'Start Tuning'}</Text>
                    </TouchableOpacity>
                </View>
            ) : (
                <View style={styles.songsContainer}>
                    {selectedSong ? (
                        <View style={{ flex: 1 }}>
                            <View style={[styles.songHeader, { justifyContent: 'space-between' }]}>
                                <View style={{ flexDirection: 'row', alignItems: 'center' }}>
                                    <TouchableOpacity onPress={() => setSelectedSong(null)}>
                                        <Ionicons name="chevron-back" size={24} color={colors.text} />
                                    </TouchableOpacity>
                                    <Text style={[styles.songTitle, { color: colors.text }]}>{selectedSong.songName}</Text>
                                </View>
                                <View style={{ flexDirection: 'row', gap: 10 }}>
                                    <TouchableOpacity onPress={exportSong} style={[styles.playBtn, { backgroundColor: colors.textSecondary }]}>
                                        <Ionicons name="share-outline" size={20} color="#fff" />
                                    </TouchableOpacity>
                                    <TouchableOpacity onPress={playSong} style={[styles.playBtn, { backgroundColor: colors.primary }]}>
                                        <Ionicons name={isPlaying ? "stop" : "play"} size={20} color="#fff" />
                                    </TouchableOpacity>
                                </View>
                            </View>

                            <View style={styles.toggleRow}>
                                <View style={styles.toggleItem}>
                                    <Switch value={playIntro} onValueChange={setPlayIntro} />
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Intro</Text>
                                </View>
                                <View style={styles.toggleItem}>
                                    <Switch value={playWithDrums} onValueChange={setPlayWithDrums} />
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Drums</Text>
                                </View>
                                <View style={styles.toggleItem}>
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>{selectedRhythm}</Text>
                                    <TouchableOpacity onPress={() => {
                                        const types = Object.keys(RHYTHM_PATTERNS);
                                        const idx = types.indexOf(selectedRhythm);
                                        setSelectedRhythm(types[(idx + 1) % types.length]);
                                    }}>
                                        <Ionicons name="swap-horizontal" size={20} color={colors.primary} />
                                    </TouchableOpacity>
                                </View>
                                <View style={styles.toggleItem}>
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Flats</Text>
                                    <Switch value={showFlats} onValueChange={setShowFlats} />
                                </View>
                                <View style={styles.toggleItem}>
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Sharps</Text>
                                    <Switch value={showSharps} onValueChange={setShowSharps} />
                                </View>
                                <View style={styles.toggleItem}>
                                    <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Whole</Text>
                                    <Switch value={showWhole} onValueChange={setShowWhole} />
                                </View>
                                {Platform.OS === 'web' && (
                                    <View style={styles.toggleItem}>
                                        <Text style={{ color: colors.textSecondary, fontSize: 10 }}>Chords</Text>
                                        <Switch value={playWithChords} onValueChange={setPlayWithChords} />
                                    </View>
                                )}
                            </View>

                            {/* Volume Mixer */}
                            {Platform.OS === 'web' && (
                                <View style={[styles.mixerSection, { backgroundColor: colors.surface, borderColor: colors.border }]}>
                                    <Text style={[styles.mixerTitle, { color: colors.text }]}>üéöÔ∏è Mixer</Text>
                                    <View style={styles.mixerRow}>
                                        <VolumeControl label="Voice" value={voiceVolume} onChange={setVoiceVolume} color={colors.primary} />
                                        <VolumeControl label="Guitar" value={chordVolume} onChange={setChordVolume} color="#FF6B6B" />
                                        <VolumeControl label="Drums" value={drumVolume} onChange={setDrumVolume} color="#4ECDC4" />
                                    </View>
                                </View>
                            )}

                            <ScrollView style={styles.lyricsScroll}>
                                {selectedSong.lyrics.map((l, i) => {
                                    const isActive = isPlaying && playbackPosition >= l.startTime && (i === selectedSong.lyrics.length - 1 || playbackPosition < selectedSong.lyrics[i + 1].startTime);
                                    return (
                                        <View key={i} style={[styles.lyricLine, isActive && { opacity: 1, transform: [{ scale: 1.02 }] }, !isActive && isPlaying && { opacity: 0.5 }]}>
                                            <View style={styles.notationRow}>
                                                <Text style={[styles.chordText, { color: colors.primary }]}>{l.chords}</Text>
                                                <Text style={[styles.noteTextSmall, { color: colors.textSecondary }]}>
                                                    {l.notes.split(' ').map(formatNote).join(' ')}
                                                </Text>
                                            </View>
                                            <Text style={[styles.lyricText, { color: colors.text, fontWeight: isActive ? 'bold' : 'normal' }]}>{l.text}</Text>
                                            {isActive && (
                                                <View style={{ height: 2, backgroundColor: colors.primary, width: 20, marginTop: 5 }} />
                                            )}
                                        </View>
                                    );
                                })}
                            </ScrollView>
                        </View>
                    ) : (
                        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
                            <FlatList
                                data={songs}
                                keyExtractor={(item: MusicAnalysisResult, index: number) => index.toString()}
                                renderItem={({ item }: { item: MusicAnalysisResult }) => (
                                    <TouchableOpacity onPress={() => setSelectedSong(item)} style={styles.songItem}>
                                        <Text style={{ color: colors.text }}>{item.songName}</Text>
                                        <Text style={{ color: colors.textSecondary, fontSize: 12 }}>{item.key} ‚Ä¢ {item.bpm} BPM</Text>
                                    </TouchableOpacity>
                                )}
                                style={{ width: '100%', flex: 1 }}
                            />

                            {isAnalyzing && <ActivityIndicator size="large" color={colors.primary} />}

                            <TouchableOpacity
                                onPress={isRecording ? stopAndAnalyze : startRecordingSong}
                                style={[styles.recordBtn, { backgroundColor: isRecording ? colors.error : colors.primary }]}
                            >
                                <Ionicons name={isRecording ? "stop" : "mic"} size={32} color="#fff" />
                                <Text style={{ color: '#fff', marginTop: 5 }}>{isRecording ? 'Stop' : 'Record Song'}</Text>
                            </TouchableOpacity>
                        </View>
                    )}
                </View>
            );
};

            const styles = StyleSheet.create({
                container: {flex: 1 },
            tabs: {flexDirection: 'row', padding: 10 },
            tab: {flex: 1, padding: 10, alignItems: 'center' },
            tabText: {fontWeight: 'bold' },
            tunerContainer: {flex: 1, padding: 20, alignItems: 'center' },
            meter: {width: '100%', alignItems: 'center', marginBottom: 40 },
            pitchText: {fontSize: 24, fontWeight: 'bold' },
            noteText: {fontSize: 84, fontWeight: 'bold' },
            visualMeter: {width: '80%', height: 40, marginTop: 20, justifyContent: 'center' },
            meterLine: {height: 2, width: '100%', position: 'absolute' },
            meterCenter: {height: 10, width: 2, position: 'absolute', left: '50%', marginTop: -4 },
            needle: {height: 20, width: 2, position: 'absolute', marginTop: -9 },
            centsText: {position: 'absolute', bottom: -20, left: 0, right: 0, textAlign: 'center', fontSize: 12 },
            stringGrid: {flexDirection: 'row', gap: 10, marginBottom: 40 },
            stringTag: {padding: 10, borderRadius: 20, backgroundColor: 'rgba(0,0,0,0.05)', width: 40, alignItems: 'center' },
            actionBtn: {padding: 15, borderRadius: 10, width: '100%', alignItems: 'center' },
            songsContainer: {flex: 1, padding: 20 },
            recordBtn: {width: 100, height: 100, borderRadius: 50, justifyContent: 'center', alignItems: 'center', position: 'absolute', bottom: 40 },
            songItem: {padding: 15, borderBottomWidth: 1, borderBottomColor: 'rgba(0,0,0,0.05)', width: '100%' },
            songHeader: {flexDirection: 'row', alignItems: 'center', marginBottom: 10 },
            songTitle: {fontSize: 18, fontWeight: 'bold', marginLeft: 10 },
            toggleRow: {flexDirection: 'row', gap: 15, marginBottom: 20, height: 40, alignItems: 'center' },
            toggleItem: {alignItems: 'center' },
            lyricsScroll: {flex: 1 },
            lyricLine: {marginBottom: 20 },
            notationRow: {flexDirection: 'row', gap: 20, marginBottom: 5 },
            chordText: {fontWeight: 'bold', fontSize: 16 },
            noteTextSmall: {fontStyle: 'italic' },
            lyricText: {fontSize: 18 },
            closeBtn: {padding: 15, alignItems: 'center', marginTop: 20 },
            playBtn: {width: 40, height: 40, borderRadius: 20, justifyContent: 'center', alignItems: 'center' },
            helpSection: {
                margin: 20,
            padding: 20,
            borderRadius: 15,
            borderWidth: 1,
    },
            helpTitle: {
                fontSize: 18,
            fontWeight: 'bold',
            marginBottom: 15,
    },
            helpItem: {
                marginBottom: 15,
    },
            helpSubitle: {
                fontWeight: 'bold',
            fontSize: 14,
            marginBottom: 5,
    },
            helpText: {
                fontSize: 13,
            lineHeight: 18,
    },
            mixerSection: {
                margin: 15,
            padding: 15,
            borderRadius: 10,
            borderWidth: 1,
    },
            mixerTitle: {
                fontSize: 14,
            fontWeight: 'bold',
            marginBottom: 10,
    },
            mixerRow: {
                flexDirection: 'row',
            justifyContent: 'space-around',
            gap: 10,
    },
            volumeControl: {
                alignItems: 'center',
            flex: 1,
    },
            volumeLabel: {
                fontSize: 10,
            fontWeight: 'bold',
            marginBottom: 5,
    },
            volumeBar: {
                flexDirection: 'row',
            gap: 3,
            alignItems: 'flex-end',
    },
            volumeSegment: {
                width: 8,
            borderRadius: 2,
    },
});

            export default MusicMakerSpark;
